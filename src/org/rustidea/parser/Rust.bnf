/*
 * Copyright 2015 Marek Kaput
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// https://doc.rust-lang.org/nightly/grammar.html
// https://doc.rust-lang.org/nightly/reference.html
// Based on Rust 1.4.0-nightly (3a407b6c4)

{
    parserClass = "org.rustidea.parser.RustParser"
    parserUtilClass = "org.rustidea.parser.RustParserUtil"

    implements = "org.rustidea.psi.RustCompositeElement"
    extends = "org.rustidea.psi.impl.RustCompositeElementImpl"

    psiClassPrefix = "Rust"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.rustidea.psi"
    psiImplPackage = "org.rustidea.psi.impl"

    elementTypeHolderClass = "org.rustidea.psi.RustTypes"
    elementTypeClass = "org.rustidea.psi.RustCompositeElementType"
    tokenTypeClass = "org.rustidea.psi.RustTokenType"

    generateTokens = true
    generateTokenAccessors = true

    extends(".*_literal") = literal

    // Matching rules of these tokens do not have any meaning in generated
    // parser. They are required to generate corresponding token types.
    // Live Preview is broken due to similarities of some tokens.
    tokens = [
        LINE_PARENT_DOC = 'regexp://\!.*'
        LINE_DOC = 'regexp:///.*'
        LINE_COMMENT = 'regexp://.*'
        BLOCK_PARENT_DOC = 'regexp:/\*\!.*\*/'
        BLOCK_DOC = 'regexp:/\*\*.*\*/'
        BLOCK_COMMENT = 'regexp:/\*.*\*/'

        KW_ABSTRACT = 'abstract'
        KW_ALIGNOF  = 'alignof'
        KW_AS       = 'as'
        KW_BECOME   = 'become'
        KW_BOX      = 'box'
        KW_BREAK    = 'break'
        KW_CONST    = 'const'
        KW_CONTINUE = 'continue'
        KW_CRATE    = 'crate'
        KW_DO       = 'do'
        KW_ELSE     = 'else'
        KW_ENUM     = 'enum'
        KW_EXTERN   = 'extern'
        KW_FALSE    = 'false'
        KW_FINAL    = 'final'
        KW_FN       = 'fn'
        KW_FOR      = 'for'
        KW_IF       = 'if'
        KW_IMPL     = 'impl'
        KW_IN       = 'in'
        KW_LET      = 'let'
        KW_LOOP     = 'loop'
        KW_MACRO    = 'macro'
        KW_MATCH    = 'match'
        KW_MOD      = 'mod'
        KW_MOVE     = 'move'
        KW_MUT      = 'mut'
        KW_OFFSETOF = 'offsetof'
        KW_OVERRIDE = 'override'
        KW_PRIV     = 'priv'
        KW_PROC     = 'proc'
        KW_PUB      = 'pub'
        KW_PURE     = 'pure'
        KW_REF      = 'ref'
        KW_RETURN   = 'return'
        KW_SELF     = 'self'
        KW_SELF_T   = 'Self'
        KW_SIZEOF   = 'sizeof'
        KW_STATIC   = 'static'
        KW_STRUCT   = 'struct'
        KW_SUPER    = 'super'
        KW_TRAIT    = 'trait'
        KW_TRUE     = 'true'
        KW_TYPE     = 'type'
        KW_TYPEOF   = 'typeof'
        KW_UNSAFE   = 'unsafe'
        KW_UNSIZED  = 'unsized'
        KW_USE      = 'use'
        KW_VIRTUAL  = 'virtual'
        KW_WHERE    = 'where'
        KW_WHILE    = 'while'
        KW_YIELD    = 'yield'

        OP_AMPERSAND        = "&"
        OP_ARROW            = "->"
        OP_ASSIGN           = "="
        OP_ASTERISK         = "*"
        OP_AT               = "@"
        OP_CARET            = "^"
        OP_CLOSE_BRACE      = "}"
        OP_CLOSE_BRACKET    = "]"
        OP_CLOSE_PAREN      = ")"
        OP_COLON            = ":"
        OP_COMMA            = ","
        OP_DOLLAR           = "$"
        OP_DOT              = "."
        OP_DOUBLE_AMPERSAND = "&&"
        OP_DOUBLE_COLON     = "::"
        OP_DOUBLE_DOT       = ".."
        OP_DOUBLE_PIPE      = "||"
        OP_EQUALS           = "=="
        OP_EXCLAMATION_MARK = "!"
        OP_FAT_ARROW        = "=>"
        OP_GREATER_THAN     = ">"
        OP_GREATER_THAN_EQ  = ">="
        OP_HASH             = "#"
        OP_LEFT_SHIFT       = "<<"
        OP_LESS_THAN        = "<"
        OP_LESS_THAN_EQ     = "<="
        OP_MINUS            = "-"
        OP_NOT_EQUALS       = "!="
        OP_OPEN_BRACE       = "{"
        OP_OPEN_BRACKET     = "["
        OP_OPEN_PAREN       = "("
        OP_PERCENT          = "%"
        OP_PIPE             = "|"
        OP_PLUS             = "+"
        OP_RIGHT_SHIFT      = ">>"
        OP_SEMICOLON        = ";"
        OP_SLASH            = "/"
        OP_TRIPLE_DOT       = "..."
        OP_UNDERSCORE       = "_"

        LIFETIME = "regexp:'[a-zA-Z_][a-zA-Z0-9_]"

        DEC_LIT = 'regexp:[0-9][0-9_]*([ui](8|16|32|64|size))?'
        BIN_LIT = 'regexp:0b[01_]+([ui](8|16|32|64|size))?'
        OCT_LIT = 'regexp:0o[0-7_]+([ui](8|16|32|64|size))?'
        HEX_LIT = 'regexp:0x[a-fA-F0-9_]+([ui](8|16|32|64|size))?'
        // Regexps <3
        FLOAT_LIT = 'regexp:([0-9][0-9_]*\.[0-9][0-9_]*([eE][-+]?[0-9_]+)?(f(32|64))?)|([0-9][0-9_]*\.)|([0-9][0-9_]*([eE][-+]?[0-9_]+)(f(32|64))?)'

        CHAR_LIT  = "regexp:'([^\t\n\r']|\\('|([nrt\\]|x[a-fA-F0-9]{1,2})|u\{[a-fA-F0-9]{1,6}\})')"
        BYTE_LIT  = "regexp:b'([\x00-\x08\x0B\x0C\x0E-\x26\x28-\x7F]|\\('|([nrt\\]|x[a-fA-F0-9]{1,2})))'"
        INVALID_BYTE_LIT = 'INVALID_BYTE_LIT'

        STR_LIT_BEGIN  = 'regexp:"'
        STR_LIT_END    = 'regexp:"'
        STR_LIT_TOKEN  = 'regexp:[^"]'
        STR_LIT_ESCAPE = 'regexp:\\("|([nrt\\]|x[a-fA-F0-9]{1,2})|u\{[a-fA-F0-9]{1,6}\})'

        BYTE_STR_LIT_BEGIN  = 'regexp:b"'
        BYTE_STR_LIT_END    = 'regexp:"'
        BYTE_STR_LIT_TOKEN  = 'regexp:[\x00-\x08\x0B\x0C\x0E-\x21\x23-\x7F]'
        BYTE_STR_LIT_ESCAPE = 'regexp:\\("|([nrt\\]|x[a-fA-F0-9]{1,2}))'
        INVALID_BYTE_STR_LIT_TOKEN = 'INVALID_BYTE_STR_LIT_TOKEN'

        RAW_STR_LIT_BEGIN = 'regexp:r#*"'
        RAW_STR_LIT_END   = 'regexp:"#*'
        RAW_STR_LIT_TOKEN = 'regexp:.'

        RAW_BYTE_STR_LIT_BEGIN = 'regexp:br#*"'
        RAW_BYTE_STR_LIT_END   = 'regexp:"#*'
        RAW_BYTE_STR_LIT_TOKEN = 'regexp:[\x00-\x7f]'
        INVALID_RAW_BYTE_STR_LIT_TOKEN = 'INVALID_RAW_BYTE_STR_LIT_TOKEN'

        MACRO_VARIABLE = 'regexp:\$[a-zA-Z_][a-zA-Z0-9_]*'
        MACRO_CALL     = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*!'

        IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'

        spaces__ = 'regexp:\s+'
    ]
}

file ::= (func | literal)+

literal ::= number_literal
          | char_literal
          | byte_literal
          | string_literal
          | byte_string_literal
          | raw_string_literal
          | raw_byte_string_literal
          | bool_literal
number_literal ::= DEC_LIT | BIN_LIT | HEX_LIT | FLOAT_LIT
char_literal ::= CHAR_LIT
byte_literal ::= BYTE_LIT | INVALID_BYTE_LIT
string_literal ::= STR_LIT_BEGIN (STR_LIT_TOKEN | STR_LIT_ESCAPE)* STR_LIT_END
byte_string_literal ::= BYTE_STR_LIT_BEGIN (BYTE_STR_LIT_TOKEN | BYTE_STR_LIT_ESCAPE | INVALID_BYTE_STR_LIT_TOKEN)* BYTE_STR_LIT_END
raw_string_literal ::= RAW_STR_LIT_BEGIN RAW_STR_LIT_TOKEN* RAW_STR_LIT_END
raw_byte_string_literal ::= RAW_BYTE_STR_LIT_BEGIN (RAW_BYTE_STR_LIT_TOKEN | INVALID_RAW_BYTE_STR_LIT_TOKEN)* RAW_BYTE_STR_LIT_END
bool_literal ::= 'true' | 'false'

func ::= 'fn' IDENTIFIER
